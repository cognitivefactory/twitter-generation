import os
import re
import logging
from typing_extensions import override

from ..helper.auto_numbered import AutoNumberedEnum


__all__ = ["ExportAdapterFormat", "ExportAdapter"]


class ExportAdapterFormat(AutoNumberedEnum):
    CSV = ()

    @override
    def __str__(self) -> str:
        return self.name.lower()

    @override
    def __repr__(self) -> str:
        return str(self)


class ExportAdapter:
    white_space = re.compile(r"\s+")
    newlines_then_something = re.compile(r"\n\n+.*", flags=re.DOTALL)

    def __init__(self, path: str = "a.out") -> None:
        self.logger = logging.getLogger("ea")
        self.__path = path
        try:
            os.makedirs(os.path.dirname(self.__path))
        except (FileExistsError, FileNotFoundError):
            pass

    def export(
        self, topic: str, sentiment: str, data: str, format: ExportAdapterFormat = ExportAdapterFormat.CSV
    ) -> None:
        with open(f"{self.__path}.raw", "a", encoding="utf-8") as f:
            # hehe
            f.write(f"\n\n---\n{topic} {sentiment}\n")
            f.write(data)

        tweets = self.__extract_tweets(data)  #! destroys data
        self.logger.debug("got %d tweets", len(tweets))

        with open(self.__path, "a", encoding="utf-8") as f:  # add to file
            match format:
                case ExportAdapterFormat.CSV:
                    for tweet in tweets:
                        f.write(f"{topic}\t{sentiment}\t{tweet}\n")

                case _:
                    raise NotImplementedError(f"Export format {format} is not supported.")

    def __format_tweet(self, tweet: str) -> str:
        return self.white_space.sub(" ", tweet[tweet.find(".") + 1 :]).strip(' "')

    def __extract_tweets(self, data: str) -> list[str]:
        # data is a text generated by the model
        # it should contain a list of tweets beginning with a number and a dot (1. )
        # and ending with the next number and dot (2. ) (or simply the end of the string for the last tweet)
        # tweets: list[str] = re.findall(r"\d+\.\s.*?(?=\d+\.\s|$)", data, flags=re.DOTALL)

        current_dot = 1
        tweets: list[str] = []

        while True:
            # find the next number and dot
            next_dot = data.find(str(current_dot + 1) + ". ")
            if next_dot == -1:
                # the last tweet does not end with a number and dot
                # but sometimes the model ends the output with multiple newlines and a sentence we don't want
                # eg
                # "1. <tweet>\n
                # \n
                # \n
                # some random sentence"
                # so we check if there are multiple newlines and a sentence
                # if there are, we remove them
                if self.newlines_then_something.search(data):
                    data = self.newlines_then_something.sub("", data)
                tweets.append(data)
                break
            # extract the tweet
            tweet = data[:next_dot]
            tweets.append(tweet)
            # update the data
            data = data[next_dot:]
            # update the current dot
            current_dot += 1

        tweets = list(map(self.__format_tweet, tweets))

        return tweets
